# C2_5 Механизм асинхронных одностронних обновлений.

<h2 align="center">Содержание:</h2>

* Определение

* Аналоги и сравнение

* Плавное введение в API

* Итог

В этой статье речь пойдет о Server-Sent Events — «события посылаемые сервером», но теперь со стороны фронтенд разработчика.

Чтобы позволить серверам передавать данные на веб-страницы по протоколу HTTP, спецификация браузера представляет интерфейс __EventSource__.

Давайте кратко разберем плюсы и минусы подходов которые мы знаем?

__Polling__

Самый простой, но самый не эффективный, метод: клиент раз в несколько секунд опрашивает сервер на наличие событий. Даже если ничего нет, то клиент делает запрос с надеждой, что что-то изменилось.

__Плюсы:__

* Очень просто

__Минусы:__

* Очень много лишних запросов

* Каждый раз стоит отсылать новые заголовки, а это лишний трафик

* События в любом случае приходят с опозданием

* Серверу приходится хранить события пока клиент не заберет их или пока они не устареют

__Long Polling__

Улучшенный вариант предыдущего метода. Клиент отправляет запрос на сервер, а сервер держит открытым соединение пока не придут какие-нибудь данные или клиент не отключится самостоятельно. Как только данные приходят — отправляется ответ, а соединение закрывается и открывается следующее.

__Плюсы по сравнению с Polling:__

* Минимальное количество запросов

* Высокая временная точность событий

* Сервер хранит события только на время переподключения

__Минусы по сравнению с Polling:__

* Более сложная схема

* Много висящих процессов

* Больше переподключений

__Server-Sent Events__

Клиент устанавливает постоянное и длительное соединение с сервером. Отсылать данные может только сервер к клиенту. Если клиент хочет что-то послать на сервер, то для этого придется использовать другую технологию/протокол. Прост в реализации на большинстве серверных платформа.

__Плюсы по сравнению с остальными:__

* Простота исполнения

* Идеальная временная точность событий

* Минимальное потребление ресурсов

__Минусы по сравнению с остальными:__

* Однонаправленная передача данных

* Ограничения для HTTP 1.*

* Нужно разбираться в новом API

Каждый способ подходит для своих задач, поэтому важно анализировать задачу и выбирать лучший способ для ее решения.


Для инициализации интерфейсы __EventSource__ вам надо написать код, который будет выглядеть примерно так -
```js
const evtSource = new EventSource("BackendFileName.py");
```

Для того, чтобы "слушать" события с сервера у __EventSource__ есть такие виды слушателей - 

| Слушатель        | Тип                  | Описание      |
| -------------    | -------------        | ------------- |
|  onerror         | nsIDOMEventListener  | JavaScript-функция, вызываемая при ошибки  |
|  onmessage       | nsIDOMEventListener  | JavaScript-функция, вызываемая при приходе сообщения  |
|  onopen          | nsIDOMEventListener  | JavaScript-функция, вызываемая после открытия соединения  |
|  readyState      | long                 | Состояние соединения, должно иметь одно из значений CONNECTING, OPEN, или CLOSED. Только для чтения  |
|  url             | DOMString            | Только для чтения  |

В дополение к открытым атрибутам два внутренних атрибута, которые не открыты напрямую:

__reconnection time__ - это время в миллисекундах, используемое для определения продолжительности ожидания после неудачной попытки соединения до повторного соединения.

__last event ID string__ - по умолчания пустая строка. Сервер может отправлять сообщение с полем id для установки этого значения.

__Итог__ - сравнили виды взаимодействий веб-приложения с сервером. Научились инициализировать __EventSource__. Узнали какие слушатели у него есть (это такая штука, которую мы писали по типу `.addEventListener("слушатель", функция)`). 


При подготовке раздела автор использовал:

https://developer.mozilla.org/ru/docs/Web/API/EventSource

https://developer.mozilla.org/ru/docs/Learn/JavaScript/Building_blocks/%D0%A1%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D1%8F

https://ru.wikipedia.org/wiki/Heartbeat-%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B5

https://apifriends.com/api-streaming/push-sse-vs-websockets/

https://ru.wikipedia.org/wiki/WebSocket

__P.S.__ данные методы использовались в основном для проектирования приложений до 2012 года. Сейчас все юзает вебсокеты - если просто, то это дуплексный протокол поверх TCP. После выхода спеки hybi 10 вебсокеты завезли во все новые браузеры того времени и они стали убер фичей, у которой уже через три месяца появилась итоговая спека 17 версии и вебсокеты теперь везде. 











# C2_5 Используем EventSource.

<h2 align="center">Содержание:</h2>

* Повторение

* Сторонний пример 

* Пример на питоне

* Итог

* Задания пропуски вставить

В прошлом разделе мы сравнили виды взаимодействий веб-приложения с сервером. Научились инициализировать __EventSource__. Узнали какие слушатели у него есть и теперь готовы писать код. 

Так как очень хороший раздел на эту тему был не переведен, автор решил перевести его на русский и предоставить к ознакомлению. Автор будет рад, если вы поймете что веб приложение может работать с сервером, который написан на любом языке программирования, а подход к написанию обработчика событий __EventSource__  будет практически одинаков в большинстве случаев.

https://developer.mozilla.org/ru/docs/Web/API/Server-sent_events/Using_server-sent_events

Тут пример с кодом игоря должен быть

__Итог__ - научились обрабатывать события, которые приходят с любого сервера. Научились вставлять ноды в дом. Считай уже фулстек разрабы!

Всякие тупые задания


Как поставить покет?

https://nodejs.org/en/download/ скачайте установите

win r
cmd
cd куда вам там надо
mkdir papka
npm --v
npm i рассказать про флаги
рассказать про npx
npm remove
npm update
хвтит















